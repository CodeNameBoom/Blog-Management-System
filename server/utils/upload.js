import multer from 'multer';
import { GridFsStorage } from 'multer-gridfs-storage';
import { MongoClient, GridFSBucket } from 'mongodb';
import dotenv from 'dotenv';

import Post from '../model/post.js';

dotenv.config();

// MongoDB credentials from environment variables
const USERNAME = process.env.MONGO_USERNAME;
const PASSWORD = process.env.MONGO_PASSWORD;

// MongoDB connection URI
const mongoURI = `mongodb+srv://${USERNAME}:${PASSWORD}@blog-web.63lam.mongodb.net/?retryWrites=true&w=majority&appName=blog-web`;

let bucket= null;

(async () => {
  try {
    const client = await MongoClient.connect(mongoURI, { useUnifiedTopology: true });
    const db = client.db();
    bucket = new GridFSBucket(db, { bucketName: 'photos' });
    console.log('Connected to MongoDB and GridFS bucket initialized');
  } catch (err) {
    console.error('MongoDB connection error:', err);
    process.exit(1); // Exit on critical error
  }
})();


// Set up GridFS storage configuration
// const storage = new GridFsStorage({

const storage = new GridFsStorage({
  url: mongoURI,
  

    file: (req, file) => {
      // File type validation (accept only images)
      const allowedTypes = ['image/png', 'image/jpg', 'image/jpeg'];

      if (allowedTypes.indexOf(file.mimetype) === -1) {
      const error = new Error('Invalid file type');
      error.code = 'INVALID_FILE_TYPE';
      throw error;
    }
  
      // Set the filename and metadata for the file
      return {
        bucketName: 'photos', // Specify the GridFS bucket name
        filename: `${Date.now()}-blog-${file.originalname}`, // Use the original filename with timestamp
        metadata: { contentType: file.mimetype },
      };
    },
  })

  
// });

// Create multer instance using GridFsStorage
export const upload = multer({ storage });


const url = 'http://localhost:8000';

// Upload image function
export const uploadImage = (req, res) => {
  if (!req.file) {
    return res.status(400).json({ message: 'No file uploaded' });
  }

  const filename = req.file.filename; // Generated by GridFsStorage
  const imageUrl = `${url}/file/${filename}`; // Use the filename for generating the URL

  console.log('Uploaded image URL:', imageUrl);

  res.status(200).json({ imageUrl });
};



// get imgurl 

export const getImage = async (req, res) => {
  const { filename } = req.params;

  if (!bucket) {
    console.error('Bucket not initialized');
    return res.status(500).json({ message: 'Bucket not initialized' });
  }

  try {
    // Check if the file exists in the bucket
    const files = await bucket.find({ filename }).toArray();
    if (!files || files.length === 0) {
      console.error('File not found:', filename);
      return res.status(404).json({ message: 'File not found' });
    }

    // Set appropriate headers
    const contentType = files[0].metadata?.contentType || 'application/octet-stream';
    res.set({
      'Content-Type': contentType,
      'Content-Disposition': `inline; filename="${filename}"`,
      'Cache-Control': 'no-store', // Prevent caching during development
    });

    // console.log('Streaming file:', filename);

    // Stream the file content to the response
    const fileStream = bucket.openDownloadStreamByName(filename);

    fileStream
      .on('error', (err) => {
        console.error('Stream error:', err);
        res.status(500).json({ message: 'Error streaming file' });
      })
      .pipe(res);

  } catch (err) {
    console.error('Error fetching file:', err);
    res.status(500).json({ message: 'Internal server error' });
  }
};



export const createPost = async (req, res) => {
  try{
    const post = await new Post(req.body);
    await post.save();

    return res.status(200).json({ success: true, message: 'Post saved successfully' });
    }catch(error){
      console.error("Error details:", error);
      if (error.name === "ValidationError") {
          const errorMessages = Object.values(error.errors)
              .map(e => e.message)
              .join(", ");
          return res.status(400).json({ success: false, message: `Validation failed: ${errorMessages}` });
      } else if (error.code === 11000) { // Duplicate key error (unique constraint violation)
          return res.status(400).json({ success: false, message: "Post with this title already exists" });
      } else {
          return res.status(500).json({ success: false, message: "An error occurred while saving the post", error: error.message });
      }
  }
}

export const getAllPosts = async (req,res) => {
  let category = req.query.category;
  let posts;
    try{

      if (category){
        posts = await Post.find({ category : category})
      }else {
        posts = await Post.find({})
      }return res.status(200).json(posts);
    }catch(error){
      return res.status(500).json({ msg: error.message })
    }
}

export const getPost = async ( request ,response) => {
  try{
    const post = await Post.findById(request.params.id);
    return response.status(200).json(post);

  }catch(error){
    return response.status(500).json({msg: error.message})
  }
}


export const updatePost = async (request, response) => {
  const { id } = request.params; // Extract the ID from the URL parameter
  const { title, content, image } = request.body;
  try {
    // Check if the body contains data to update
    if (!request.body || Object.keys(request.body).length === 0) {
      return response.status(400).json({ msg: 'No update data provided' });
    }

    // Find the post by ID
    const post = await Post.findById(request.params.id);
    if (!post) {
      return response.status(404).json({ msg: 'Post not found' });
    }

    // Optionally, handle specific fields like title, content, imageUrl

    // Update the post
    const updatedPost = await Post.findByIdAndUpdate(
      id,
      { title, content, image },
      { new: true } // Return the updated post
    );

    if (updatedPost) {
      return response.status(200).json({ message: 'Post updated successfully', updatedPost });
    } else {
      return response.status(404).json({ message: 'Post not found' });
    }
  } catch (error) {
    console.error('Error updating post:', error);
    return response.status(500).json({ message: 'Failed to update post' });
  }
};

export const deletePost = async ( req, res) => {
  try{
      const post = await Post.findById(req.params.id);

      if(!post){
        return res.status(404).json({msg: 'post not found'});
      }

      await post.delete();

      return res.status(200).json({msg: 'post deleted successfully'})
  }catch(error){
    return res.status(500).json({error: error.message});

  }
}



